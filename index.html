# Flask API (Receiver + Sender) basic structure

# الخطوة 1: monkey_patch يجب أن يكون أول شيء (لـ gevent)
from gevent import monkey
monkey.patch_all()

# الخطوة 2: الآن نستورد باقي المكتبات
from flask import Flask, request, jsonify
from flask_socketio import SocketIO, emit
import sqlite3
import logging
from time import time

# الخطوة 3: إنشاء التطبيق بعد monkey_patch
app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret123'

socketio = SocketIO(app, cors_allowed_origins='*', async_mode='gevent')

# طباعة الطلبات
@app.before_request
def log_request_info():
    print(f"Request: {request.method} {request.url}")

# الخطوة 4: إنشاء قاعدة البيانات داخل سياق التطبيق
with app.app_context():
    conn = sqlite3.connect('candles.db', check_same_thread=False)
    c = conn.cursor()
    c.execute("""
    CREATE TABLE IF NOT EXISTS candles (
        time INTEGER PRIMARY KEY,
        open REAL,
        high REAL,
        low REAL,
        close REAL
    )
    """)
    conn.commit()

    # Load existing candles from DB
    CANDLES = []
    rows = c.execute("SELECT * FROM candles ORDER BY time ASC").fetchall()
    for r in rows:
        CANDLES.append({
            "time": r[0],
            "open": r[1],
            "high": r[2],
            "low": r[3],
            "close": r[4]
        })

# ----------------------- Configuration -----------------------

# API Key protection
API_KEY = "SUPER_SECRET_KEY_12345"

# ----------------------- Main Page (New)
@app.route('/')
def index():
    return "<h1>API Server Running</h1><p>Visit <a href='/api/candles'>Candles API</a></p>"

# ----------------------- REST API (Receiver + Data Access) -----------------------

# Fetch all candles
@app.get('/api/candles')
def get_all_candles():
    rows = c.execute("SELECT * FROM candles ORDER BY time ASC").fetchall()
    result = [
        {"time": r[0], "open": r[1], "high": r[2], "low": r[3], "close": r[4]}
        for r in rows
    ]
    return jsonify(result)

# Fetch last N candles
@app.get('/api/candles/last/<int:n>')
def get_last_n(n):
    rows = c.execute("SELECT * FROM candles ORDER BY time DESC LIMIT ?", (n,)).fetchall()
    result = [
        {"time": r[0], "open": r[1], "high": r[2], "low": r[3], "close": r[4]}
        for r in rows[::-1]
    ]
    return jsonify(result)

# Fetch last candle only
@app.get('/api/candle/last')
def get_last():
    r = c.execute("SELECT * FROM candles ORDER BY time DESC LIMIT 1").fetchone()
    if not r:
        return jsonify({"error": "no candles"}), 404
    return jsonify({"time": r[0], "open": r[1], "high": r[2], "low": r[3], "close": r[4]})

# Delete old candles by time range
@app.delete('/api/candles/delete/<int:before_time>')
def delete_old(before_time):
    c.execute("DELETE FROM candles WHERE time < ?", (before_time,))
    conn.commit()
    return jsonify({"status": "deleted", "before": before_time})

# Receive single candle (Receiver)
@app.post('/api/candle')
def receive_candle():
    ip = request.remote_addr
    if not rate_limit(ip):
        return jsonify({'error': 'Too many requests'}), 429
    
    # API Key verification
    api_key = request.headers.get("X-API-KEY")
    if api_key != API_KEY:
        return jsonify({'error': 'Invalid API Key'}), 401

    data = request.json
    if not data:
        return jsonify({'error': 'Invalid JSON'}), 400

    # Validate required keys
    required_keys = ['time', 'open', 'high', 'low', 'close']
    for key in required_keys:
        if key not in data:
            return jsonify({'error': f'Missing key: {key}'}), 400

    try:
        CANDLES.append(data)
        c.execute("INSERT OR REPLACE INTO candles VALUES (?, ?, ?, ?, ?)", 
                 (data['time'], data['open'], data['high'], data['low'], data['close']))
        conn.commit()

        # push to WebSocket
        socketio.emit('new_candle', data)
    except Exception as e:
        logging.error(f"Database error in receive_candle: {str(e)}")
        return jsonify({'error': 'Database error'}), 500

    return jsonify({'status': 'ok'})

@app.post('/api/candles')
def receive_candles():
    ip = request.remote_addr
    if not rate_limit(ip):
        return jsonify({'error': 'Too many requests'}), 429
    
    # API Key verification
    api_key = request.headers.get("X-API-KEY")
    if api_key != API_KEY:
        return jsonify({'error': 'Invalid API Key'}), 401

    data = request.json
    if not isinstance(data, list):
        return jsonify({'error': 'Expected list of candles'}), 400

    try:
        for cndl in data:
            # Validate required keys for each candle
            required_keys = ['time', 'open', 'high', 'low', 'close']
            for key in required_keys:
                if key not in cndl:
                    return jsonify({'error': f'Missing key: {key} in candle'}), 400

            CANDLES.append(cndl)
            c.execute("INSERT OR REPLACE INTO candles VALUES (?, ?, ?, ?, ?)", 
                     (cndl['time'], cndl['open'], cndl['high'], cndl['low'], cndl['close']))
        conn.commit()

        socketio.emit('batch_candles', data)
    except Exception as e:
        logging.error(f"Database error in receive_candles: {str(e)}")
        return jsonify({'error': 'Database error'}), 500

    return jsonify({'status': 'ok'})

@app.post('/api/candle/update')
def update_candle():
    ip = request.remote_addr
    if not rate_limit(ip):
        return jsonify({'error': 'Too many requests'}), 429
    
    # API Key verification
    api_key = request.headers.get("X-API-KEY")
    if api_key != API_KEY:
        return jsonify({'error': 'Invalid API Key'}), 401

    data = request.json
    if not data:
        return jsonify({'error': 'Invalid JSON'}), 400

    # Validate required keys
    required_keys = ['time', 'open', 'high', 'low', 'close']
    for key in required_keys:
        if key not in data:
            return jsonify({'error': f'Missing key: {key}'}), 400

    try:
        # Update in DB
        c.execute("INSERT OR REPLACE INTO candles VALUES (?, ?, ?, ?, ?)", 
                 (data['time'], data['open'], data['high'], data['low'], data['close']))
        conn.commit()

        socketio.emit('update_candle', data)
    except Exception as e:
        logging.error(f"Database error in update_candle: {str(e)}")
        return jsonify({'error': 'Database error'}), 500

    return jsonify({'status': 'ok'})

# ----------------------- Logging System -----------------------
logging.basicConfig(filename='server.log', level=logging.INFO, format='%(asctime)s %(message)s')

# ----------------------- Rate Limit -----------------------
last_call = {}
RATE_LIMIT_SEC = 0.3

def rate_limit(ip):
    now = time()
    if ip in last_call and now - last_call[ip] < RATE_LIMIT_SEC:
        return False
    last_call[ip] = now
    return True

# ----------------------- WebSocket (Sender) -----------------------

@socketio.on('connect')
def on_connect():
    emit('init_candles', CANDLES)

@socketio.on('disconnect')
def on_disconnect():
    pass

# ----------------------- Run -----------------------

if __name__ == '__main__':
    print("Starting server on http://localhost:5001")
    socketio.run(app, host='0.0.0.0', port=5001)  # تم تغيير المنفذ إلى 5001
